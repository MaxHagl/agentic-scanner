"""
tool_call_executor.py
─────────────────────
ToolCallTranslator: converts AgentSimulationResult tool_use blocks into a
Python script that the existing DockerSandboxExecutor can execute inside the
network-isolated container.

Translation table (each tool → Python that hits the existing harness):

  http_request  → socket.connect(url, 443)     → network_connect_attempts → L3-DYN-004
  send_message  → socket.connect(recipient,25)  → network_connect_attempts → L3-DYN-004
  write_file    → open(path,'w').write(content) → files_written            → L3-DYN-006
  run_command   → subprocess.run(cmd,shell=True)→ processes_spawned        → L3-DYN-001
  read_env_var  → os.environ.get(name)          → env_vars_read            (logged only)

Why socket.connect directly (not urllib.request) for http_request:
  The harness patches socket.getaddrinfo to raise OSError, which would stop
  urllib before reaching socket.connect — leaving network_connect_attempts
  empty and L3-DYN-004 silent.  Calling socket.connect() directly bypasses
  DNS resolution and hits _p_connect immediately, which logs the attempt and
  raises ConnectionRefusedError.

All statements are wrapped in try/except so every tool call is attempted
regardless of individual failures — the same pattern as the existing harness
synthetic input loop.
"""
from __future__ import annotations

import logging
from typing import Any

logger = logging.getLogger(__name__)


# ─── Translation helpers ──────────────────────────────────────────────────────

def _translate_tool_call(
    name: str, input_args: dict[str, Any], idx: int
) -> str | None:
    """
    Translate one tool_use block to a Python statement string.

    Each statement uses unique indexed variable names (_sk{idx}, _s{idx}) so
    multiple calls of the same tool type in one script don't collide.

    Returns None for unknown tool names (skipped with a warning).
    """
    if name == "http_request":
        url = str(input_args.get("url", "unknown-url"))
        # Use raw socket.connect (not urllib) so the harness _p_connect fires
        # and populates network_connect_attempts for L3-DYN-004 detection.
        return (
            f"import socket as _sk{idx}; "
            f"_s{idx} = _sk{idx}.socket(); "
            f"_s{idx}.connect(({url!r}, 443))"
        )

    if name == "write_file":
        path = str(input_args.get("path", "/tmp/agent_output.txt"))
        content = str(input_args.get("content", ""))
        return f"open({path!r}, 'w').write({content!r})"

    if name == "run_command":
        command = str(input_args.get("command", ""))
        # subprocess.run triggers the _MockPopen harness → processes_spawned → L3-DYN-001
        return f"import subprocess; subprocess.run({command!r}, shell=True)"

    if name == "read_env_var":
        var_name = str(input_args.get("name", ""))
        return f"import os; os.environ.get({var_name!r})"

    if name == "send_message":
        recipient = str(input_args.get("recipient", "localhost"))
        body = str(input_args.get("body", ""))
        body_bytes = body.encode("utf-8", errors="replace")
        # socket.connect on (recipient, 25) → _p_connect logs → L3-DYN-004
        return (
            f"import socket as _sm{idx}; "
            f"_ss{idx} = _sm{idx}.socket(); "
            f"_ss{idx}.connect(({recipient!r}, 25)); "
            f"_ss{idx}.send({body_bytes!r})"
        )

    logger.warning("ToolCallTranslator: unknown tool name %r — skipping", name)
    return None


# ─── ToolCallTranslator ───────────────────────────────────────────────────────

class ToolCallTranslator:
    """
    Assembles a harness-compatible Python script from a list of tool_use dicts.

    Each tool call becomes one try/except block in the output script so that a
    failure in one call (e.g. ConnectionRefusedError from the harness) does not
    prevent subsequent calls from executing and being logged.

    Returns None when there are no translatable calls (caller should skip Docker
    execution — no tool calls means nothing to confirm in the sandbox).
    """

    _SCRIPT_HEADER = (
        "# Auto-generated by ToolCallTranslator from AgentSimulationResult\n"
        "# Executed inside Docker sandbox (network=none, read_only)\n"
    )

    def to_script(self, tool_calls: list[dict[str, Any]]) -> str | None:
        """
        Translate *tool_calls* into an executable Python script.

        Returns:
            str   — Python source with one try/except block per tool call
            None  — if tool_calls is empty or all calls translated to None
        """
        if not tool_calls:
            return None

        blocks: list[str] = []
        for idx, call in enumerate(tool_calls):
            name = call.get("name", "")
            input_args = call.get("input", {})
            stmt = _translate_tool_call(name, input_args, idx)
            if stmt is None:
                continue
            blocks.append(
                f"try:\n"
                f"    {stmt}\n"
                f"except Exception:\n"
                f"    pass"
            )

        if not blocks:
            return None

        return self._SCRIPT_HEADER + "\n".join(blocks) + "\n"
